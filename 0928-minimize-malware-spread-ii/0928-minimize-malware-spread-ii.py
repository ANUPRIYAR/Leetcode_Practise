class Solution:
    def dfs(self, graph, curnode, parent, curtime, discoverytime, low, isinfected, malwarespreadcount):
        low[curnode] = discoverytime[curnode] = curtime
        ismalwarespread = isinfected[curnode]
        componentsize = 1

        for neighbor in range(len(graph[curnode])):
            if graph[curnode][neighbor] == 1:
                if discoverytime[neighbor] == 0:
                    subtreesize = self.dfs(graph, neighbor, curnode, curtime + 1, discoverytime, low, isinfected, malwarespreadcount)

                    if subtreesize == 0:
                        ismalwarespread = True
                    else:
                        componentsize += subtreesize

                    if low[neighbor] >= discoverytime[curnode]:
                        malwarespreadcount[curnode] += subtreesize

                    low[curnode] = min(low[curnode], low[neighbor])
                elif parent != neighbor:
                    low[curnode] = min(low[curnode], discoverytime[neighbor])

        return 0 if ismalwarespread else componentsize


    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        rows, cols = len(graph), len(graph[0])
        discoverytime= [0] * rows
        low = [0]* rows
        malwarespreadcount = [0] * rows
        maxsavednodes = 0
        nodetoremove = initial[0]

        isinfected = [False]* rows

        for node in initial:
            isinfected[node] = True


        for node in initial:
            if discoverytime[node] == 0:
                self.dfs(graph, node, -1, 1, discoverytime, low,isinfected,  malwarespreadcount)
            if malwarespreadcount[node] > maxsavednodes or (malwarespreadcount[node]== maxsavednodes and node < nodetoremove):
                maxsavednodes = malwarespreadcount[node]
                nodetoremove = node

        return nodetoremove

    



        